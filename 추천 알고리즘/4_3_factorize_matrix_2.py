# -*- coding: utf-8 -*-
"""4-3.factorize_matrix_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FFi6R-VXuTMRxGnqjeICV8fadFE56itI
"""

# 행렬 분해 : R = P * Q.T
# NaN이 포함된 R이 주어졌을 때 P, Q를 추정한다.
# by Stochastic Gradient Descent
# -------------------------------------------
import numpy as np
from sklearn.metrics import mean_squared_error

N = np.NaN
R = np.array([[4, N, N, 2, N],
              [N, 5, N, 3, 1],
              [N, N, 3, 4, 4],
              [5, 2, 1, 2, N]], dtype=np.float32)

n_users, n_items = R.shape

# R에서 NaN이 아닌 값만 골라 놓는다. (행번호, 열번호, 데이터) => (n_row, n_col, R_data)
non_zeros = [(i, j, R[i,j]) for i in range(n_users) for j in range(n_items) if np.isnan(R[i,j]) != True]
non_zeros



K = 3   # latent feature 개수
# P = np.random.rand(n_users, K).astype(np.float32)    # user-factor matrix
# Q = np.random.rand(K, n_items).astype(np.float32)    # factor-item matrix.

P = np.random.normal(loc = 0.0, scale = 1.0 / K, size = (n_users, K)).astype(np.float32)
Q = np.random.normal(loc = 0.0, scale = 1.0 / K, size = (K, n_items)).astype(np.float32)

R[0, 3]

def get_rmse(R, P, Q, non_zeros):
    error = 0
    
    ER = np.dot(P, Q)  # estimated R
    
    # R에서 NaN이 아닌 행, 열 번호
    n_row = [x[0] for x in non_zeros]
    n_col = [x[1] for x in non_zeros]

    # R에서 NaN이 아닌 데이터와 추정-R (ER)에서 해당 위치의 데이터
    R_data = R[n_row, n_col]       # R[0, 3] = 2, R[[0, 1], [0, 1]] = [4, 5]
    ER_data = ER[n_row, n_col]

    mse = mean_squared_error(R_data, ER_data)
    return np.sqrt(mse)

steps = 1000
alpha = 0.01
beta = 0.01

# SGD 기법으로 P, Q 행렬을 추정한다.
for step in range(steps):
    for i, j, r in non_zeros:
        # 실제 값과 추정 값으로 오류 값 계산
        eij = r - np.dot(P[i, :], Q[:, j])
        
        # update
        P[i, :] += alpha * (eij * Q[:, j] - beta * P[i, :])
        Q[:, j] += alpha * (eij * P[i, :] - beta * Q[:, j])
    
    rmse = get_rmse(R, P, Q, non_zeros)
    if step % 50 == 0:
        print('Step :', step, ' rmse =', np.round(rmse, 4))

ER = np.dot(P, Q)   # estimated R

print('\nR :')
print(np.round(R, 2))
print('\nEstimated R :')
print(np.round(ER, 2))   
print('\nP :')
print(np.round(P, 2))
print('\nQ.T :')
print(np.round(Q.T, 2))

